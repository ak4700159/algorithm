
## 분할 정복 알고리즘 주의 사항 
- 부분 문제의 수가 늘어나는 경우
- 부분 문제의 크기가 늘어나는 경우
- 해당 알고리즘을 사용했을 때 속도향상이 없는 경우(입력값이 작은 경우)

ex) 피보나치 수열 : 입력의 크기가 다음 스텝에서 2n -3 으로 늘어남

<br/>
<br/>


## Greedy 알고리즘
가능한 해들 중에서 가장 좋은 해를 찾는 문제.

입력 데이터 간의 관계를 고려하지 않고 수행 과정에서 욕심 내어 최소값 또는 최대값을 가지는 데이터를 선택한다.

한 번 선택하면 이를 절대로 번복하지 않는다.

제한적인 문제들로만 해결 가능하다. 항상 최선의 결과를 얻을 수 없다.


## 구현
먼저 전탐색 방식에서 효율적으로(과정을 최소화) 접근해야 한다.

왜냐하면 하나의 선택지가 다른 선택지에 영향을 미치기 때문에 여러 상황에 대해 고려해야 한다. 즉, 선택지에 대한 dependency를 고려해야 한다.

<br/>
<br/>


## 최소 신장 트리 (MST Minium Spanning Tree)
MST는 주어진 가중치 그래프에서 사이클이 없이 모든 점들을 연결시킨 트리들 중 선분들의 가중치 합이 최소인 트리다. 

그래프는 실제 세계 속 관계를 찾아보기 위해 나타낸다. 

트리 구조는 그래프의 일종이다. 단, 그래프에서 사이클이 없어야 트리가 된다.

## Spainng Tree는 
- 그래프에서 사이클이 없어야 된다.
- 연결되지 않은 접점(vertex)이 없어야 된다. 
- 그리고 모든 가중치의 합이 최소가 되어야 한다.
- 무방향 그래프 + 연결 그래프(모든 정점 간에 경로가 존재 : n-1)이어야 한다.



## MST 구하는 과정
### 가장 간단한 방식
- 임의로 정점 하나를 선택
- 선택한 정점과 연결된 정점들 중에서 가장 낮은 가중치 갖는 정점으로 연결
- 위 과정을 모든 정점이 선택될 때까지 반복(사이클이 발생하지 않아야됨)
- 결과가 최소 신장 트리가 아니기에 모든 정점을 시작으로 트리를 구성하는 가중치 합이 최소가 되는 트리 선택


### Kruskal

Edge를 중심으로 최적의 경로를 찾는 방식이다.
Minium을 먼저 고려해야됨.그래서 정점이 아닌 간선을 선택하며 경로 탐색(n-1 개 간선 선택)

<br>

입력 : 가중치 그래프 G = {V, E}, |V| = n, |E| = m  // 출력 : 최소 신장 트리 T

    1. 가중치의 오름차순으로 선분들을 정렬. 정렬된 선분 리스트를 L이라고 가정
    2. T = 0 // 트리 초기화
    3. while( T의 선분 수 < n-1 >){
    4.     L에서 가장 작은 가중치를 가진 선분 e를 가져오고, e를 L에서 제거한다.
    5.    if(e가 T에 추가되어 사이클을 만들지 않으면) e를 T에 추가한다.
    6.    else e를 버린다.
    7. }
    8. return T


### Prim
무작위 정점에서 시작하여 Edge를 하나씩 추가하며 하나의 Tree를 구성한다.

greedy search + dynamic program 을 활용해 시간 복잡도를 개선한다. 

여기서 dynamic program이란? 동적으로(실시간으로) 선택 가능한 정보를 그때마다 업데이트한다. 업데이트한 내용은 greedy search에 영향을 미치게 된다.

입력: 가중치 그래프 G=(V,E), |V|=n, |E|=m
출력: 최소 신장 트리 T

    1. 그래프 G에서 임의의 점 p를 시작점으로 선택하고, D[p]=0으로 놓는다.
    2. for (점 p가 아닌 각 점 v에 대하여) { // D 초기화 과정
    3. if ( 선분 (p,v)가 그래프에 있으면)
    4. D[v] = 선분 (p,v)의 가중치
    5. else
    6. D[v]=∞ }

    7. T= {p}
    8. while (T에 있는 점의 수 < n) { // T 업데이트
    9. T에 속하지 않은 각 점 v에 대하여, D[v]가 최소인 점 vmin과 연결된 선분 (u,vmin)을 T에 추가한다. 단, u는 T에 속한 점이고, 점 vmin도 T에 추가된다.
    10. for (T에 속하지 않은 각 점 w에 대해서) { // D 업데이트
    11. if (선분 (vmin,w)의 가중치 < D[w])
    12. D[w] = 선분 (vmin,w)의 가중치} }
    13. return T


## 결론
Prim 알고리즘은 O(n2)이 걸린다. Prim 알고리즘은 vertex와 연결된 edge의 개수가 몇 개 있냐에 따라 성능이 크게 달라진다. 하지만 worst case인 경우엔 n2의 시간 복잡도를 가진다. 즉, 현재 놓여져있는 상황에 따라 Prim이 더 효율적일 수 있고 Kruskal이 더 효율적일 수 있다.